
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Prostate cancer phase field model &#8212; mocafe 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Angiogenesis phase field model" href="angiogenesis_2d.html" />
    <link rel="prev" title="Demo Gallery" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demo-doc-prostate-cancer2d-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="prostate-cancer-phase-field-model">
<span id="sphx-glr-demo-doc-prostate-cancer2d-py"></span><h1>Prostate cancer phase field model<a class="headerlink" href="#prostate-cancer-phase-field-model" title="Permalink to this headline">¶</a></h1>
<p>In this short demo we will show you how to simulate a phase field model described by G. Lorenzo and collaborators
in 2016 <span id="id1">[<a class="reference internal" href="../bib.html#id2" title="Guillermo Lorenzo, Michael A Scott, Kevin Tew, Thomas J R Hughes, Yongjie Jessica Zhang, Lei Liu, Guillermo Vilanova, and Hector Gomez. Tissue-scale, personalized modeling and simulation of prostate cancer growth. Proceedings of the National Academy of Sciences, 2016. URL: www.pnas.org/cgi/doi/10.1073/pnas.1615791113, doi:10.1073/pnas.1615791113.">LST+16</a>]</span> using FEniCS and mocafe. The model was published on PNAS in 2016 and presents a
continuous mathematical model able to reproduce the growth pattern of prostate cancer at tissue scale.</p>
<section id="how-to-run-this-example-on-mocafe">
<h2>How to run this example on mocafe<a class="headerlink" href="#how-to-run-this-example-on-mocafe" title="Permalink to this headline">¶</a></h2>
<p>Make sure you have FEniCS and mocafe installed and download the source script of this page (see above for the link).
Then, simply run it using python:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">python3 prostate_cancer2d.py</span>
</pre></div>
</div>
<p>If you are in a hurry, you can exploit parallelization to run the simulation faster:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">mpirun -n 4 python3 prostate_cancer2d.py</span>
</pre></div>
</div>
<p>Notice that the number following the <code class="docutils literal notranslate"><span class="pre">-n</span></code> option is the number of MPI processes you using for parallelizing the
simulation. You can change it accordingly with your CPU.</p>
</section>
<section id="brief-introduction-to-the-mathematical-model">
<h2>Brief introduction to the mathematical model<a class="headerlink" href="#brief-introduction-to-the-mathematical-model" title="Permalink to this headline">¶</a></h2>
<p>The model is composed of just two partial differential equations (PDEs). The first describes the evolution of the
cancer phase field  <span class="math notranslate nohighlight">\(\varphi\)</span>, and reads:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \varphi}{\partial t} = \lambda \nabla^2 \varphi - \frac{1}{\tau}\frac{dF(\varphi)}{d\varphi}
+ \chi \sigma - A \varphi\]</div>
<p>The second describes the variation of nutrients concentration <span class="math notranslate nohighlight">\(\sigma\)</span> in time:</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \sigma}{\partial t} = \epsilon \nabla^2\sigma + s - \delta\cdot\varphi - \gamma\cdot\sigma\]</div>
<p>A complete discussion of these two equations is above the purpose of this short demo so, if you’re interested, we
suggest you to refer to the original paper <span id="id2">[<a class="reference internal" href="../bib.html#id2" title="Guillermo Lorenzo, Michael A Scott, Kevin Tew, Thomas J R Hughes, Yongjie Jessica Zhang, Lei Liu, Guillermo Vilanova, and Hector Gomez. Tissue-scale, personalized modeling and simulation of prostate cancer growth. Proceedings of the National Academy of Sciences, 2016. URL: www.pnas.org/cgi/doi/10.1073/pnas.1615791113, doi:10.1073/pnas.1615791113.">LST+16</a>]</span>. However, we just mention some of their main features.</p>
<p>The first equation describes a cancer development driven by both proliferation, and apoptosis. Cancer cells are
assumed to duplicate in presence of nutrient and their proliferation is, indeed, described by the term
<span class="math notranslate nohighlight">\(\chi \sigma\)</span>, which contains the nutrients concentration. Apoptosis is, instead assumed to occurr at a constant
rate and is represented in the equation by the term <span class="math notranslate nohighlight">\(-A \varphi\)</span>.</p>
<p>The second equation describes the diffusion of the nutrients with the Fick’s low of diffusion
<span id="id3">[<a class="reference internal" href="../bib.html#id3" title="Wikipedia contributors. Fick's laws of diffusion — Wikipedia, the free encyclopedia. 2021. [Online; accessed 9-December-2021]. URL: https://en.wikipedia.org/w/index.php?title=Fick%27s_laws_of_diffusion&amp;oldid=1058693490.">Wikipediacontributors21</a>]</span>. The equation assumes that the nutrient is supplied constantly in the domain with
a distribution <span class="math notranslate nohighlight">\(s\)</span>, and that the nutrient is consumed at a constant rate by the cancer cells (term
<span class="math notranslate nohighlight">\(-\delta\varphi\)</span>). Additionaly, the nutrient is supposed to decay at a constant rate, described by the term
<span class="math notranslate nohighlight">\(\gamma \sigma\)</span>.</p>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<section id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>After the math, let’s see the code. To reproduce this model we need first to import everything we need throughout
the simulation. Notice that while most of the packages are provided by mocafe, we also use some other stuff.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">fenics</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="n">file_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="n">mocafe_folder</span> <span class="o">=</span> <span class="n">file_folder</span><span class="o">.</span><span class="n">parent</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mocafe_folder</span><span class="p">))</span>  <span class="c1"># appending mocafe path. Must be removed</span>
<span class="kn">from</span> <span class="nn">mocafe.fenut.solvers</span> <span class="kn">import</span> <span class="n">PETScProblem</span><span class="p">,</span> <span class="n">PETScNewtonSolver</span>
<span class="kn">from</span> <span class="nn">mocafe.fenut.fenut</span> <span class="kn">import</span> <span class="n">get_mixed_function_space</span><span class="p">,</span> <span class="n">setup_xdmf_files</span>
<span class="kn">from</span> <span class="nn">mocafe.fenut.mansimdata</span> <span class="kn">import</span> <span class="n">setup_data_folder</span>
<span class="kn">from</span> <span class="nn">mocafe.expressions</span> <span class="kn">import</span> <span class="n">EllipseField</span><span class="p">,</span> <span class="n">PythonFunctionField</span>
<span class="kn">from</span> <span class="nn">mocafe.fenut.parameters</span> <span class="kn">import</span> <span class="n">from_dict</span>
<span class="kn">import</span> <span class="nn">mocafe.litforms.prostate_cancer</span> <span class="k">as</span> <span class="nn">pc_model</span>
</pre></div>
</div>
<p>Then, it is useful (even though not necessary) to do a number of operations before running our simulation.</p>
<p>First of all, we shut down the logging messages from FEniCS, leaving only the error messages in case something goes
<em>really</em> wrong. If you want to check out the FEniCS messages, you can comment this line.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fenics</span><span class="o">.</span><span class="n">set_log_level</span><span class="p">(</span><span class="n">fenics</span><span class="o">.</span><span class="n">LogLevel</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we define the MPI rank for each process. Generally speaking, this is necessary for running the simulation in
parallel using <code class="docutils literal notranslate"><span class="pre">mpirun</span></code>, even though in this simulation is not largely used, as we are going to see.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">comm</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">comm_world</span>
<span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
</pre></div>
</div>
<p>Then, we can define the files where to save our result for visualization and post-processing. The suggested format
for saving FEniCS simulations is using <code class="docutils literal notranslate"><span class="pre">.xdmf</span></code> files, which can easily be visualized in
<a class="reference external" href="https://www.paraview.org/">Paraview</a>.</p>
<p>Even though FEniCS provides its own classes and method to define these files, in the following we use two mocafe
methods for defining:</p>
<ul class="simple">
<li><p>first, the folder where to save the result of the simulation. In this case, the folder will be based inside
the current folder (<code class="docutils literal notranslate"><span class="pre">base_location</span></code>) and it’s called demo_out/prostate_cancer2d;</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data_folder</span> <span class="o">=</span> <span class="n">setup_data_folder</span><span class="p">(</span><span class="n">folder_path</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;{file_folder/Path(&#39;demo_out&#39;)}/prostate_cancer_2d&quot;</span><span class="p">,</span>
                                <span class="n">auto_enumerate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>then, the two files for the cancer <span class="math notranslate nohighlight">\(\varphi\)</span> and for the nutrients <span class="math notranslate nohighlight">\(\sigma\)</span>, which will be called
<code class="docutils literal notranslate"><span class="pre">phi.xdmf</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma.xdmf</span></code>.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_xdmf</span><span class="p">,</span> <span class="n">sigma_xdmf</span> <span class="o">=</span> <span class="n">setup_xdmf_files</span><span class="p">([</span><span class="s2">&quot;phi&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">],</span> <span class="n">data_folder</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we define the parameters of the differential equation using a mocafe <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> object, which is created
for this purpose.</p>
<p>A Parameters object can be initialized in several ways. In the following, we define it from a
dictionary where each key is the parameter name and the value is the actual value of the parameter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">parameters</span> <span class="o">=</span> <span class="n">from_dict</span><span class="p">({</span>
    <span class="s2">&quot;phi0_in&quot;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span>  <span class="c1"># adimentional</span>
    <span class="s2">&quot;phi0_out&quot;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>  <span class="c1"># adimdimentional</span>
    <span class="s2">&quot;sigma0_in&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>  <span class="c1"># adimentional</span>
    <span class="s2">&quot;sigma0_out&quot;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span>  <span class="c1"># adimentional</span>
    <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>  <span class="c1"># years</span>
    <span class="s2">&quot;lambda&quot;</span><span class="p">:</span> <span class="mf">1.6E5</span><span class="p">,</span>  <span class="c1"># (um^2) / years</span>
    <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>  <span class="c1"># years</span>
    <span class="s2">&quot;chempot_constant&quot;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span>  <span class="c1"># adimensional</span>
    <span class="s2">&quot;chi&quot;</span><span class="p">:</span> <span class="mf">600.0</span><span class="p">,</span>  <span class="c1"># Liters / (gram * years)</span>
    <span class="s2">&quot;A&quot;</span><span class="p">:</span> <span class="mf">600.0</span><span class="p">,</span>  <span class="c1"># 1 / years</span>
    <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="mf">5.0E6</span><span class="p">,</span>  <span class="c1"># (um^2) / years</span>
    <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="mf">1003.75</span><span class="p">,</span>  <span class="c1"># grams / (Liters * years)</span>
    <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span>  <span class="c1"># grams / (Liters * years)</span>
    <span class="s2">&quot;s_average&quot;</span><span class="p">:</span> <span class="mf">961.2</span><span class="p">,</span>  <span class="c1"># grams / (Liters * years)</span>
    <span class="s2">&quot;s_max&quot;</span><span class="p">:</span> <span class="mf">73.</span><span class="p">,</span>
    <span class="s2">&quot;s_min&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">73.</span>
<span class="p">})</span>
</pre></div>
</div>
</section>
<section id="definition-of-the-spatial-domain-and-the-function-space">
<h3>Definition of the spatial domain and the function space<a class="headerlink" href="#definition-of-the-spatial-domain-and-the-function-space" title="Permalink to this headline">¶</a></h3>
<p>The first step toward the simulation of our system is the definition of the space where the simulation takes
place. Similarly to the original paper, we are going to simulate the model on a 2D square mesh of dimension
2000 x 2000 <span class="math notranslate nohighlight">\(\mu m\)</span>. This is pretty simple to do using FEniCs, which provides the class <code class="docutils literal notranslate"><span class="pre">RectangleMesh</span></code>
to do this job.</p>
<p>More precisely, in the following we are going to define a mesh of the dimension described above, with 512
points for each side.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nx</span> <span class="o">=</span> <span class="mi">130</span>
<span class="n">ny</span> <span class="o">=</span> <span class="n">nx</span>
<span class="n">x_max</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># um</span>
<span class="n">x_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1000</span>  <span class="c1"># um</span>
<span class="n">y_max</span> <span class="o">=</span> <span class="n">x_max</span>
<span class="n">y_min</span> <span class="o">=</span> <span class="n">x_min</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">RectangleMesh</span><span class="p">(</span><span class="n">fenics</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">),</span>
                            <span class="n">fenics</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">),</span>
                            <span class="n">nx</span><span class="p">,</span>
                            <span class="n">ny</span><span class="p">)</span>
</pre></div>
</div>
<p>From the mesh defined above, we can then define the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code>. If your not familiar enough with FEniCS
to know what a function space is, we suggest you to have a look to the first pages of The Fenics Tutorial
<span id="id4">[<a class="reference internal" href="../bib.html#id4" title="Hans Petter Langtangen and Anders Logg. Solving PDEs in Python. Springer, 2017. ISBN 978-3-319-52461-0. doi:10.1007/978-3-319-52462-7.">LL17</a>]</span>, but basically the function space defines the set of the piece-wise
polynomial function that will be used to approximate the solutions of our PDEs.</p>
<p>Since the model we wish to simulate is composed of two coupled equations, we need to define a MixedElement function
space with two different elements. In this implementation, we will use for both equations the same element
type, “CG” (Continuous Galerking), of the first order, which can be created in FEniCS simply using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cg1_element</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">fenics</span><span class="o">.</span><span class="n">triangle</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># define element</span>
<span class="n">mixed_element</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">MixedElement</span><span class="p">([</span><span class="n">cg1_element</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># define mixed element</span>
<span class="n">function_space</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">mixed_element</span><span class="p">)</span>  <span class="c1"># define function space for the given mesh</span>
</pre></div>
</div>
<p>However, the very same operation can be performed in just one line using the following method provided by
mocafe:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function_space</span> <span class="o">=</span> <span class="n">get_mixed_function_space</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="initial-boundary-conditions">
<h3>Initial &amp; boundary conditions<a class="headerlink" href="#initial-boundary-conditions" title="Permalink to this headline">¶</a></h3>
<p>Since the model is a system of PDEs, we need both initial and boundary conditions to find a unique solution.</p>
<p>In this implementation we will consider natural Neumann boundary conditions for both <span class="math notranslate nohighlight">\(\varphi\)</span> and
:math`sigma`, which means that the derivative in space of the two fields is zero along the entire boundary.
This is an easy pick for FEniCS, since it will automatically apply this condition for us without requiring any
command from the user.</p>
<p>As initial condition for <span class="math notranslate nohighlight">\(\varphi\)</span>, according to another paper of the same author <span id="id5">[<a class="reference internal" href="../bib.html#id5" title="G. Lorenzo, M. A. Scott, K. Tew, T. J.R. Hughes, and H. Gomez. Hierarchically refined and coarsened splines for moving interface problems, with particular application to phase-field models of prostate tumor growth. Computer Methods in Applied Mechanics and Engineering, 319:515–548, jun 2017. doi:10.1016/j.cma.2017.03.009.">LST+17</a>]</span>, we
will define an elliptical tumor with the given semiaxes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">semiax_x</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># um</span>
<span class="n">semiax_y</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># um</span>
</pre></div>
</div>
<p>With FEniCS we can do so by defining an expression which ‘mathematically’ represent our initial condition.
Indeed, an <code class="docutils literal notranslate"><span class="pre">Expression</span></code> is the FEniCS way to define symbolic mathematical function and they can be defined
using simple C++ code as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi0_max</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">phi0_min</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c1"># cpp code that returns True if the point x is inside the ellipse, and False otherwise</span>
<span class="n">is_in_ellipse_cpp_code</span> <span class="o">=</span> <span class="s2">&quot;((pow(x[0] / semiax_x, 2)) + (pow(x[1] / semiax_y, 2)) &lt;= 1)&quot;</span>
<span class="c1"># cpp code that returns 1 if the above statement is True, and 0 otherwise</span>
<span class="n">phi0_cpp_code</span> <span class="o">=</span> <span class="n">is_in_ellipse_cpp_code</span> <span class="o">+</span> <span class="s2">&quot; ? phi0_max : phi0_min&quot;</span>
<span class="c1"># FEniCS expression, built from cpp code defined above</span>
<span class="n">phi0</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">Expression</span><span class="p">(</span><span class="n">phi0_cpp_code</span><span class="p">,</span>
                         <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                         <span class="n">semiax_x</span><span class="o">=</span><span class="n">semiax_x</span><span class="p">,</span>
                         <span class="n">semiax_y</span><span class="o">=</span><span class="n">semiax_y</span><span class="p">,</span>
                         <span class="n">phi0_max</span><span class="o">=</span><span class="n">phi0_max</span><span class="p">,</span>
                         <span class="n">phi0_min</span><span class="o">=</span><span class="n">phi0_min</span><span class="p">)</span>
</pre></div>
</div>
<p>However, if you don’t feel confident in defining your own expression with the FEniCS interface, you can use
the one provided by mocafe:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi0</span> <span class="o">=</span> <span class="n">EllipseField</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
                    <span class="n">semiax_x</span><span class="o">=</span><span class="n">semiax_x</span><span class="p">,</span>
                    <span class="n">semiax_y</span><span class="o">=</span><span class="n">semiax_y</span><span class="p">,</span>
                    <span class="n">inside_value</span><span class="o">=</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;phi0_in&quot;</span><span class="p">),</span>
                    <span class="n">outside_value</span><span class="o">=</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;phi0_out&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The FEniCS expression must then be interpolated in the function space in order to obtain a
FEniCS Function. Again, explaining why we need to do so is something that goes beyond the purpose of this small
demo, but think about it as a necessary operation required to transform the ‘symbolic’ function provided by the
<code class="docutils literal notranslate"><span class="pre">Expression</span></code> into the actual set of values of our expression in our spatial domain, so we can use them to
calculate our solution.</p>
<p>The interpolation can be done simply calling the FEniCS method <code class="docutils literal notranslate"><span class="pre">interpolate</span></code>, which takes as arguments the
expression to be projected and the function space where to do the projection. Notice that, since the function space
we defined is mixed, we must choose one of the sub-field to define the function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi0</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">phi0</span><span class="p">,</span> <span class="n">function_space</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">())</span>
</pre></div>
</div>
<p>Notice also that since the mixed function space is defined by two identical function spaces, it makes no
difference to pick sub(0) or sub(1).</p>
<p>Then, we can save the initial condition of the <span class="math notranslate nohighlight">\(\varphi\)</span> field in the <cite>.xdmf</cite> file we defined at the
beginning, simply calling the method <code class="docutils literal notranslate"><span class="pre">write(phi0,</span> <span class="pre">0)</span></code>. The second argument, 0, just represent the fact that
this is the value of the field for the time 0. As we’re going to see in the simulation, the file <code class="docutils literal notranslate"><span class="pre">phi_xdmf</span></code> can
collect the values of phi for each time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi_xdmf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">phi0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, after having defined the initial condition for <span class="math notranslate nohighlight">\(\varphi\)</span>, let’s define the initial for
<span class="math notranslate nohighlight">\(\sigma\)</span>. Following the hypothesis of original author <span id="id6">[<a class="reference internal" href="../bib.html#id5" title="G. Lorenzo, M. A. Scott, K. Tew, T. J.R. Hughes, and H. Gomez. Hierarchically refined and coarsened splines for moving interface problems, with particular application to phase-field models of prostate tumor growth. Computer Methods in Applied Mechanics and Engineering, 319:515–548, jun 2017. doi:10.1016/j.cma.2017.03.009.">LST+17</a>]</span>, we will assume a nutrient
distribution that is 0.2 inside the cancer and 1. outside. So, we can define this distribution similarly to
what we just did for <code class="docutils literal notranslate"><span class="pre">phi0</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sigma0</span> <span class="o">=</span> <span class="n">EllipseField</span><span class="p">(</span><span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
                      <span class="n">semiax_x</span><span class="o">=</span><span class="n">semiax_x</span><span class="p">,</span>
                      <span class="n">semiax_y</span><span class="o">=</span><span class="n">semiax_y</span><span class="p">,</span>
                      <span class="n">inside_value</span><span class="o">=</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;sigma0_in&quot;</span><span class="p">),</span>
                      <span class="n">outside_value</span><span class="o">=</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;sigma0_out&quot;</span><span class="p">))</span>
<span class="n">sigma0</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">function_space</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">collapse</span><span class="p">())</span>
<span class="n">sigma_xdmf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pde-system-definition">
<h3>PDE System definition<a class="headerlink" href="#pde-system-definition" title="Permalink to this headline">¶</a></h3>
<p>After having defined the initial conditions for the system, we continue with the definition of the system
itself.</p>
<p>First of all, we define the two variables, <code class="docutils literal notranslate"><span class="pre">phi</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma</span></code>, for which the system will be solved. Since the
two equations are coupled (i.e. they depend on each other) the easiest way to do so is to define a ‘vector’
function <code class="docutils literal notranslate"><span class="pre">u</span></code> on the mixed function space:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
</pre></div>
</div>
<p>And then to split the vector in its two components, which represent <span class="math notranslate nohighlight">\(\varphi\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>After having defined phi and sigma, we defined the <span class="math notranslate nohighlight">\(s\)</span> function, which represent the distribution of
nutrient that is supplied to the system.</p>
<p>In the original paper they simulated the model for both a constant distibution and for a randomic one. In
this implementation we chose to do the the latter, which is slightly more complex, even though made
simplier by the mocafe <code class="docutils literal notranslate"><span class="pre">Expression</span></code> <code class="docutils literal notranslate"><span class="pre">PythonFunctionField</span></code>.</p>
<p>This class allows us to use a python function, such as a lambda function, to define the values of a FEniCS function.
In the following, indeed, we make use of a lambda function and of the methods provided by the module <code class="docutils literal notranslate"><span class="pre">random</span></code>
to define the random distribution mentioned above. Indeed, The pyhton function it is used by this class to evaluate
the value of the FEniCS function at each point of the mesh. Notice that the function given as imput must always have
at least on input (x in this case), representing the spatial point.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s_expression</span> <span class="o">=</span> <span class="n">PythonFunctionField</span><span class="p">(</span>
    <span class="n">python_fun</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;s_average&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;s_min&quot;</span><span class="p">),</span>
                                                                          <span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;s_max&quot;</span><span class="p">)),</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now, we have everything in place to define our PDE system. Since FEniCS uses the Finite Element Method (FEM) to
approximate the solution we need to define the so called ‘weak form’ of our system. This operation is not difficult
to do with the Unified Form Language (UFL) of FEniCS and, if you’re not experienced with that, you are encouraged to
have a look to The Fenics Tutorial to start <span id="id7">[<a class="reference internal" href="../bib.html#id4" title="Hans Petter Langtangen and Anders Logg. Solving PDEs in Python. Springer, 2017. ISBN 978-3-319-52461-0. doi:10.1007/978-3-319-52462-7.">LL17</a>]</span>. However, the weak form of this system
is already defined in mocefe, so we can exploit that without wondering too much about weak form construction:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">TestFunctions</span><span class="p">(</span><span class="n">function_space</span><span class="p">)</span>
<span class="n">weak_form</span> <span class="o">=</span> <span class="n">pc_model</span><span class="o">.</span><span class="n">prostate_cancer_form</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">phi0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span> <span class="o">+</span> \
    <span class="n">pc_model</span><span class="o">.</span><span class="n">prostate_cancer_nutrient_form</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">s_expression</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<p>Still, you are invited to notice a couple of interesting things:</p>
<ul class="simple">
<li><p>the trial function necessary to define every weak form are simply variables in FEniCS;</p></li>
<li><p>the variable <code class="docutils literal notranslate"><span class="pre">weak_form</span></code> is defined as the sum of two elements <code class="docutils literal notranslate"><span class="pre">prostate_cancer_form</span></code> and
<code class="docutils literal notranslate"><span class="pre">prostate_cancer_nutrient_form</span></code>, which represent, of course, the two differential equations of the system</p></li>
<li><p>the variable <code class="docutils literal notranslate"><span class="pre">weak_form</span></code> depends on <code class="docutils literal notranslate"><span class="pre">phi</span></code>, <code class="docutils literal notranslate"><span class="pre">sigma</span></code>, their initial values, <code class="docutils literal notranslate"><span class="pre">s</span></code>, and the model parameters,
exactly like the equations defined above</p></li>
</ul>
<p>This was just to give you a taste of how simple it is to use UFL do define systems of differential equation, and how
well is integrated in Python. If you want to know more about it, you’re again invited to have a look to The FEniCS
Tutorial <span id="id8">[<a class="reference internal" href="../bib.html#id4" title="Hans Petter Langtangen and Anders Logg. Solving PDEs in Python. Springer, 2017. ISBN 978-3-319-52461-0. doi:10.1007/978-3-319-52462-7.">LL17</a>]</span>.</p>
</section>
<section id="simulation-setup">
<h3>Simulation setup<a class="headerlink" href="#simulation-setup" title="Permalink to this headline">¶</a></h3>
<p>Now that everything is set up, simulating this mathematical model is just a matter of solving the PDE system defined
above for each time step.</p>
<p>To do so, we start defining the total number of steps to simulate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_steps</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<p>Then, we define a progress bar with <code class="docutils literal notranslate"><span class="pre">tqdm</span></code> in order to monitor the iteration progress. Notice that the progress
bar is defined only if the rank of the process is 0. This is necessary to avoid every process to print out a
different progress bar.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">progress_bar</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>Then, we need to define how we want FEniCS to solve or PDE system. This can be done with just a few lines of code in
mocafe, which are necessary to set up the right solver for our problem:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">jacobian</span> <span class="o">=</span> <span class="n">fenics</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">weak_form</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">PETScProblem</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">weak_form</span><span class="p">,</span> <span class="p">[])</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">PETScNewtonSolver</span><span class="p">({</span><span class="s2">&quot;ksp_type&quot;</span><span class="p">:</span> <span class="s2">&quot;gmres&quot;</span><span class="p">,</span> <span class="s2">&quot;pc_type&quot;</span><span class="p">:</span> <span class="s2">&quot;asm&quot;</span><span class="p">},</span>
                           <span class="n">mesh</span><span class="o">.</span><span class="n">mpi_comm</span><span class="p">())</span>
</pre></div>
</div>
<p>The few lines above might look a bit obscure if you’re not experienced with FEM and numerical methods in general,
but we will do our best to clarify a bit.</p>
<p>Like every numerical method, FEM translates a system of PDEs in an algebraic system of linear equations of which
the solution is an estimate of the real PDE system solution. FEniCS delegates the construction and the solution of
this system to <a class="reference external" href="https://petsc.org/release/">PETSc</a> (Portable, Extensible Toolkit for Scientific Computation),
its default algebraic backend.</p>
<p>The job of the class <code class="docutils literal notranslate"><span class="pre">PETScProblem</span></code> is to construct the algebraic system of equations from the weak form,
its jacobian matrix, and the boundary conditions. For our example:</p>
<ul class="simple">
<li><p>we already defined the weak form above, so we can use it as it is;</p></li>
<li><p>we can retrieve the Jacobian matrix, which is a multidimensional version of the traditional matematical derivative,
symply calling the FEniCS command <code class="docutils literal notranslate"><span class="pre">derivative</span></code>;</p></li>
<li><p>we left the list of boundary conditions empty (<code class="docutils literal notranslate"><span class="pre">[]</span></code>) because we are considering natural Neumann boundary
conditions, which are applied by default by the FEM method.</p></li>
</ul>
<p>The job of the class <code class="docutils literal notranslate"><span class="pre">PETScNewtonSolver</span></code>, instead, is to define the algorithm to be used to solve the ‘problem’
defined above, and to apply it for the computation of the actual solution. The algorithm may be one of the many
available for solving algebraic systems of equations. The reason of the name ‘Newton Solver` is just because
the system of PDEs we are solving is non-linear and thus it requires this class of solvers. More precisely, in this
implementation we are asking to PETSc to solve our system with a Krylov solver of type ‘gmres’
(<code class="docutils literal notranslate"><span class="pre">&quot;ksp_type&quot;:</span> <span class="pre">&quot;gmres&quot;</span></code>) using a preconditioner called “asm” (<code class="docutils literal notranslate"><span class="pre">&quot;pc_type&quot;:</span> <span class="pre">&quot;asm&quot;</span></code>). For further details, you
are suggested to have a look to chapter 9 of the book “The Finite Element Method: Theory, Implementation,
and Applications”, by Larson and Bengzon <span id="id9">[<a class="reference internal" href="../bib.html#id6" title="Mats G. Larson and Fredrik Bengzon. Non-linear Problems, pages 225–239. Springer Berlin Heidelberg, Berlin, Heidelberg, 2013. URL: https://doi.org/10.1007/978-3-642-33287-6_9, doi:10.1007/978-3-642-33287-6_9.">LB13</a>]</span></p>
</section>
<section id="simulation">
<h3>Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h3>
<p>Finally, we can iterate in time to solve the system with the given solver at each time step.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">current_step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
    <span class="c1"># update time</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s2">&quot;dt&quot;</span><span class="p">)</span>

    <span class="c1"># solve the problem with the solver defined by the given parameters</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>

    <span class="c1"># save new values to phi0 and sigma0, in order for them to be the initial condition for the next step</span>
    <span class="n">fenics</span><span class="o">.</span><span class="n">assign</span><span class="p">([</span><span class="n">phi0</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">],</span> <span class="n">u</span><span class="p">)</span>

    <span class="c1"># save current solutions to file</span>
    <span class="n">phi_xdmf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">phi0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># write the value of phi at time t</span>
    <span class="n">sigma_xdmf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># write the value of sigma at time t</span>

    <span class="c1"># update progress bar</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demo-doc-prostate-cancer2d-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/8a40d8aa3269e4a75362d293cf86804a/prostate_cancer2d.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">prostate_cancer2d.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/df27622401ccd258725549d238b56ddb/prostate_cancer2d.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">prostate_cancer2d.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">mocafe</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">In the following, you can find the complete package documentation, including demos and bibliography:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Demo Gallery</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Prostate cancer phase field model</a></li>
<li class="toctree-l2"><a class="reference internal" href="angiogenesis_2d.html">Angiogenesis phase field model</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../code_documentation.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bib.html">Bibliography</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Demo Gallery</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Demo Gallery</a></li>
      <li>Next: <a href="angiogenesis_2d.html" title="next chapter">Angiogenesis phase field model</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Franco Pradelli.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.3.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/demo_doc/prostate_cancer2d.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>